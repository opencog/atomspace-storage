/*
 * tests/persist/BasicSaveUTest.cxxtest
 *
 * Most basic, simplest sniff test, saves and restores a few atoms.
 * Copyright (C) 2008, 2009 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/atomspace/Atom.h>
#include <opencog/atomspace/Link.h>
#include <opencog/atomspace/Node.h>
#include <opencog/atomspace/SimpleTruthValue.h>
#include <opencog/atomspace/TLB.h>
#include <opencog/persist/AtomStorage.h>

#include <opencog/server/CogServer.h>
#include <opencog/util/Logger.h>

using namespace opencog;

class BasicSaveUTest :  public CxxTest::TestSuite
{
	private:
		AtomSpace *as;
		const char * dbname;
		const char * username;
		const char * passwd;

		Node *n1;
		Node *n2;
		Node *n3;
		Link *l;
		Atom *a1;
		Atom *a2;
		Atom *a3;
		Atom *al;

	public:

		BasicSaveUTest(void)
		{
			logger().setLevel(Logger::DEBUG);
			logger().setPrintToStdoutFlag(true);

			dbname = "persist-test";
			username = "linas";
			passwd = "asdf";
		}

		~BasicSaveUTest()
		{
			// erase the log file if no assertions failed
			if (!CxxTest::TestTracker::tracker().suiteFailed())
				std::remove(logger().getFilename().c_str());
		}

		void setUp(void);

		void tearDown(void) { }
		void single_atom_save_restore(std::string id);
		void add_to_table(AtomTable *, std::string id);
		void check_table(AtomTable *, std::string id);

		void test_single_atom(void);
		void test_table(void);
};

void BasicSaveUTest::setUp(void)
{
	CogServer& cogserver = static_cast<CogServer&>(server());
	as = cogserver.getAtomSpace();
}

// ============================================================

static void atomCompare(Atom *a, Atom *b)
{
	Link *la = dynamic_cast<Link *>(a);
	Link *lb = dynamic_cast<Link *>(b);

	TSM_ASSERT("No atom found", b != NULL);

	TSM_ASSERT_EQUALS("Type mistmatch", a->getType(), b->getType());

	// Only links can have arity
	if (la && lb)
	{
		TSM_ASSERT_EQUALS("Arity mistmatch", la->getArity(), lb->getArity());

		if (0 < la->getArity())
		{
			std::vector<Handle> outa = la->getOutgoingSet();
			std::vector<Handle> outb = lb->getOutgoingSet();
			for (int i=0; i< la->getArity(); i++)
			{
				if (outa[i] != outb[i])
				{
					TSM_ASSERT_EQUALS("outgoing set mis-match", 
						outa[i].value(), outb[i].value());
				}
			}
		}
	}

	const TruthValue &ta = a->getTruthValue();
	const TruthValue &tb = b->getTruthValue();
	TSM_ASSERT("Truth value miscompare", ta==tb);

	if (!(ta == tb))
	{
		fprintf(stderr, "Error, truth value miscompare, "
		        "ma=%f mb=%f ca=%f cb=%f\n",
		        ta.getMean(), tb.getMean(), ta.getCount(), tb.getCount());
	}
}

// ============================================================
/**
 * A simple test cases that tests the save and restore of 
 * a couple of nodes and a link. Does not test atomspaces at all.
 */
void BasicSaveUTest::single_atom_save_restore(std::string id)
{
	AtomStorage *store = new AtomStorage(dbname, username, passwd);
	TSM_ASSERT("Not connected to database", store->connected());

	// Create an atom ... 
	Atom *a = new Node(SCHEMA_NODE, id + "someNode");
	SimpleTruthValue stv(0.55, 0.6);
	a->setTruthValue(stv);
	TLB::addAtom(a);

	// Store the atom ... 
	store->storeAtom(a);

	// Fetch it back ...
	Handle h = TLB::getHandle(a);
	Atom *b = store->getAtom(h);

	// Are they equal ??
	atomCompare(a,b);

	// Create a second atom, connect it to the first
	// with a link. Save it, fetch it ... are they equal?
	Atom *a2 = new Node(SCHEMA_NODE, id + "otherNode");
	TLB::addAtom(a2);
	store->storeAtom(a2);

	std::vector<Handle> hvec;
	hvec.push_back(TLB::getHandle(a));
	hvec.push_back(TLB::getHandle(a2));

	Link *l = new Link(SET_LINK, hvec);
	TLB::addAtom(l);
	store->storeAtom(l);

	Atom *lb = store->getAtom(TLB::getHandle(l));
	atomCompare(l,lb);

	delete store;
}

// ============================================================

void BasicSaveUTest::add_to_table(AtomTable *table, std::string id)
{
	// Create an atom ... 
	n1 = new Node(SCHEMA_NODE, id + "fromNode");
	SimpleTruthValue stv(0.11, 33);
	n1->setTruthValue(stv);
	a1 = n1;
	table->add(a1);

	n2 = new Node(SCHEMA_NODE, id + "toNode");
	SimpleTruthValue stv2(0.22, 66);
	n2->setTruthValue(stv2);
	a2 = n2;
	table->add(a2);

	n3 = new Node(SCHEMA_NODE, id + "third wheel");
	SimpleTruthValue stv3(0.33, 99);
	n3->setTruthValue(stv3);
	a3 = n3;
	table->add(a3);

	std::vector<Handle> hvec;
	hvec.push_back(TLB::getHandle(a1));
	hvec.push_back(TLB::getHandle(a2));
	hvec.push_back(TLB::getHandle(a3));

	l = new Link(SET_LINK, hvec);
	al = l;
	table->add(l);
}

void BasicSaveUTest::check_table(AtomTable *table, std::string id)
{
	Handle hb1 = table->getHandle(n1);
	Atom *b1 = TLB::getAtom(hb1);
	atomCompare(a1, b1);

	Handle hb2 = table->getHandle(n2);
	Atom *b2 = TLB::getAtom(hb2);
	atomCompare(a2, b2);

	Handle hb3 = table->getHandle(n3);
	Atom *b3 = TLB::getAtom(hb3);
	atomCompare(a3, b3);

	std::vector<Handle> hvec;
	hvec.push_back(TLB::getHandle(b1));
	hvec.push_back(TLB::getHandle(b2));
	hvec.push_back(TLB::getHandle(b3));

	Link *lb = new Link(SET_LINK, hvec);
	Handle hlb = table->getHandle(lb);
	Atom *bl = TLB::getAtom(hlb);
	atomCompare(al, bl);
}

// ============================================================

void BasicSaveUTest::test_single_atom(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

   single_atom_save_restore("aaa ");
   single_atom_save_restore("bbb ");
   single_atom_save_restore("ccc ");
   single_atom_save_restore("ddd ");
   single_atom_save_restore("eee ");

	logger().debug("END TEST: %s", __FUNCTION__);
}

void BasicSaveUTest::test_table(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	AtomStorage *store = new AtomStorage(dbname, username, passwd);
	TSM_ASSERT("Not connected to database", store->connected());

	AtomTable *table1 = new AtomTable();
   add_to_table(table1, "aaa ");
   add_to_table(table1, "bbb ");
   add_to_table(table1, "ccc ");
   add_to_table(table1, "ddd ");
   add_to_table(table1, "eee ");

	store->store(*table1);
	delete store;

	// Reopen connection, and load the atom table.
	store = new AtomStorage(dbname, username, passwd);
	TSM_ASSERT("Not connected to database", store->connected());

	AtomTable *table2 = new AtomTable();

	store->load(*table2);

   check_table(table2, "aaa ");
   check_table(table2, "bbb ");
   check_table(table2, "ccc ");
   check_table(table2, "ddd ");
   check_table(table2, "eee ");

	delete store;
	delete table1;
	delete table2;
	logger().debug("END TEST: %s", __FUNCTION__);
}

/* ============================= END OF FILE ================= */
