/*
 * tests/persist/BasicSaveUTest.cxxtest
 *
 * Most basic, simplest sniff test, saves and restores a few atoms.
 * Copyright (C) 2008, 2009 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/atomspace/Atom.h>
#include <opencog/atomspace/Link.h>
#include <opencog/atomspace/Node.h>
#include <opencog/atomspace/SimpleTruthValue.h>
#include <opencog/atomspace/TLB.h>
#include <opencog/persist/AtomStorage.h>

#include <opencog/server/CogServer.h>
#include <opencog/util/Logger.h>

using namespace opencog;

class BasicSaveUTest :  public CxxTest::TestSuite
{
	private:
		AtomSpace *as;

	public:

		BasicSaveUTest(void)
		{
			logger().setLevel(Logger::DEBUG);
			logger().setPrintToStdoutFlag(true);
		}

		~BasicSaveUTest()
		{
			// erase the log file if no assertions failed
			if (!CxxTest::TestTracker::tracker().suiteFailed())
				std::remove(logger().getFilename().c_str());
		}

		void setUp(void);

		void tearDown(void) { }

		void test_single_atom(void);
		void test_table(void);
};

void BasicSaveUTest::setUp(void)
{
	CogServer& cogserver = static_cast<CogServer&>(server());
	as = cogserver.getAtomSpace();
}

// ============================================================
static int atomCompare(Atom *a, Atom *b)
{
	int rc = 0;
	Link *la = dynamic_cast<Link *>(a);
	Link *lb = dynamic_cast<Link *>(b);
	if (NULL == b)
	{
		fprintf(stderr, "Error: No atom found\n");
		return -1;
	}

	if (a->getType() != b->getType())
	{
		fprintf(stderr, "Error, type mis-match, a=%d b=%d\n", a->getType(), b->getType());
		rc --;
	}
	if (la->getArity() != lb->getArity())
	{
		fprintf(stderr, "Error, arity mis-match, a=%d b=%d\n", la->getArity(), lb->getArity());
		rc --;
	}
	if (0 < la->getArity())
	{
		std::vector<Handle> outa = la->getOutgoingSet();
		std::vector<Handle> outb = lb->getOutgoingSet();
		for (int i =0; i< la->getArity(); i++)
		{
			if (outa[i] != outb[i])
			{
				fprintf(stderr, "Error, outgoing set mis-match, "
				        "i=%d a=%lx b=%lx\n", i, outa[i].value(), outb[i].value());
				rc --;
			}
		}
	}
	if (!(a->getTruthValue() == b->getTruthValue()))
	{
		const TruthValue &ta = a->getTruthValue();
		const TruthValue &tb = b->getTruthValue();
		fprintf(stderr, "Error, truth value miscompare, "
		        "ma=%f mb=%f ca=%f cb=%f\n",
		        ta.getMean(), tb.getMean(), ta.getCount(), tb.getCount());
		rc --;
	}
	return rc;
}

// ============================================================
/**
 * A simple test cases that tests the save and restore of 
 * a couple of nodes and a link. Does not test atomspaces at all.
 */
static void single_atom_test(std::string id)
{
	AtomStorage *store = new AtomStorage("persist-test", "linas", NULL);

	// Create an atom ... 
	Atom *a = new Node(SCHEMA_NODE, id + "someNode");
	SimpleTruthValue stv(0.55, 0.6);
	a->setTruthValue(stv);
	TLB::addAtom(a);

	// Store the atom ... 
	store->storeAtom(a);

	// Fetch it back ...
	Handle h = TLB::getHandle(a);
	Atom *b = store->getAtom(h);

	// Are they equal ??
	int rc = atomCompare(a,b);
	if (!rc) 
	{
		printf("atom compare success\n");
	}

	// Create a second atom, connect it to the first
	// with a link. Save it, fetch it ... are they equal?
	Atom *a2 = new Node(SCHEMA_NODE, id + "otherNode");
	TLB::addAtom(a2);
	store->storeAtom(a2);

	std::vector<Handle> hvec;
	hvec.push_back(TLB::getHandle(a));
	hvec.push_back(TLB::getHandle(a2));

	Link *l = new Link(SET_LINK, hvec);
	TLB::addAtom(l);
	store->storeAtom(l);

	Atom *lb = store->getAtom(TLB::getHandle(l));
	rc = atomCompare(l,lb);
	if (!rc) 
	{
		printf("link compare success\n");
	}

	delete store;
}

// ============================================================
static void add_to_table(AtomTable *table, std::string id)
{
	// Create an atom ... 
	Atom *a = new Node(SCHEMA_NODE, id + "fromNode");
	SimpleTruthValue stv(0.11, 33);
	a->setTruthValue(stv);
	table->add(a);

	Atom *a2 = new Node(SCHEMA_NODE, id + "toNode");
	SimpleTruthValue stv2(0.22, 66);
	a2->setTruthValue(stv2);
	table->add(a2);

	Atom *a3 = new Node(SCHEMA_NODE, id + "third wheel");
	SimpleTruthValue stv3(0.33, 99);
	a3->setTruthValue(stv3);
	table->add(a3);

	std::vector<Handle> hvec;
	hvec.push_back(TLB::getHandle(a));
	hvec.push_back(TLB::getHandle(a2));
	hvec.push_back(TLB::getHandle(a3));

	Link *l = new Link(SET_LINK, hvec);
	table->add(l);
}

// ============================================================

void BasicSaveUTest::test_single_atom(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

#if 0
   single_atom_test("aaa ");
   single_atom_test("bbb ");
   single_atom_test("ccc ");
   single_atom_test("ddd ");
   single_atom_test("eee ");
#endif
	logger().debug("END TEST: %s", __FUNCTION__);
}

void BasicSaveUTest::test_table(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

#if 0
	AtomStorage *store = new AtomStorage("persist-test", "linas", NULL);

	AtomTable *table = new AtomTable();
   add_to_table(table, "aaa ");
   add_to_table(table, "bbb ");
   add_to_table(table, "ccc ");
   add_to_table(table, "ddd ");
   add_to_table(table, "eee ");

	store->store(*table);

	delete store;
#endif
	logger().debug("END TEST: %s", __FUNCTION__);
}

/* ============================= END OF FILE ================= */
