// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZMQMessages.proto

#ifndef PROTOBUF_ZMQMessages_2eproto__INCLUDED
#define PROTOBUF_ZMQMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ZMQMessages_2eproto();
void protobuf_AssignDesc_ZMQMessages_2eproto();
void protobuf_ShutdownFile_ZMQMessages_2eproto();

class ZMQAttentionValueHolderMessage;
class ZMQVersionHandleMessage;
class ZMQSingleTruthValueMessage;
class ZMQTruthValueMessage;
class ZMQTrailMessage;
class ZMQAtomMessage;
class ZMQRequestMessage;
class ZMQReplyMessage;

enum ZMQTruthValueType {
  ZMQTruthValueTypeSimple = 0,
  ZMQTruthValueTypeCount = 1,
  ZMQTruthValueTypeNull = 2,
  ZMQTruthValueTypeIndefinite = 3,
  ZMQTruthValueTypeComposite = 4
};
bool ZMQTruthValueType_IsValid(int value);
const ZMQTruthValueType ZMQTruthValueType_MIN = ZMQTruthValueTypeSimple;
const ZMQTruthValueType ZMQTruthValueType_MAX = ZMQTruthValueTypeComposite;
const int ZMQTruthValueType_ARRAYSIZE = ZMQTruthValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZMQTruthValueType_descriptor();
inline const ::std::string& ZMQTruthValueType_Name(ZMQTruthValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZMQTruthValueType_descriptor(), value);
}
inline bool ZMQTruthValueType_Parse(
    const ::std::string& name, ZMQTruthValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZMQTruthValueType>(
    ZMQTruthValueType_descriptor(), name, value);
}
enum ZMQAtomType {
  ZMQAtomTypeNode = 0,
  ZMQAtomTypeLink = 1
};
bool ZMQAtomType_IsValid(int value);
const ZMQAtomType ZMQAtomType_MIN = ZMQAtomTypeNode;
const ZMQAtomType ZMQAtomType_MAX = ZMQAtomTypeLink;
const int ZMQAtomType_ARRAYSIZE = ZMQAtomType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZMQAtomType_descriptor();
inline const ::std::string& ZMQAtomType_Name(ZMQAtomType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZMQAtomType_descriptor(), value);
}
inline bool ZMQAtomType_Parse(
    const ::std::string& name, ZMQAtomType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZMQAtomType>(
    ZMQAtomType_descriptor(), name, value);
}
enum ZMQFunctionType {
  ZMQgetAtom = 0,
  ZMQgetName = 1
};
bool ZMQFunctionType_IsValid(int value);
const ZMQFunctionType ZMQFunctionType_MIN = ZMQgetAtom;
const ZMQFunctionType ZMQFunctionType_MAX = ZMQgetName;
const int ZMQFunctionType_ARRAYSIZE = ZMQFunctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZMQFunctionType_descriptor();
inline const ::std::string& ZMQFunctionType_Name(ZMQFunctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZMQFunctionType_descriptor(), value);
}
inline bool ZMQFunctionType_Parse(
    const ::std::string& name, ZMQFunctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZMQFunctionType>(
    ZMQFunctionType_descriptor(), name, value);
}
// ===================================================================

class ZMQAttentionValueHolderMessage : public ::google::protobuf::Message {
 public:
  ZMQAttentionValueHolderMessage();
  virtual ~ZMQAttentionValueHolderMessage();
  
  ZMQAttentionValueHolderMessage(const ZMQAttentionValueHolderMessage& from);
  
  inline ZMQAttentionValueHolderMessage& operator=(const ZMQAttentionValueHolderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQAttentionValueHolderMessage& default_instance();
  
  void Swap(ZMQAttentionValueHolderMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQAttentionValueHolderMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQAttentionValueHolderMessage& from);
  void MergeFrom(const ZMQAttentionValueHolderMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 STI = 1;
  inline bool has_sti() const;
  inline void clear_sti();
  static const int kSTIFieldNumber = 1;
  inline ::google::protobuf::int32 sti() const;
  inline void set_sti(::google::protobuf::int32 value);
  
  // required int32 LTI = 2;
  inline bool has_lti() const;
  inline void clear_lti();
  static const int kLTIFieldNumber = 2;
  inline ::google::protobuf::int32 lti() const;
  inline void set_lti(::google::protobuf::int32 value);
  
  // required int32 VLTI = 3;
  inline bool has_vlti() const;
  inline void clear_vlti();
  static const int kVLTIFieldNumber = 3;
  inline ::google::protobuf::int32 vlti() const;
  inline void set_vlti(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ZMQAttentionValueHolderMessage)
 private:
  inline void set_has_sti();
  inline void clear_has_sti();
  inline void set_has_lti();
  inline void clear_has_lti();
  inline void set_has_vlti();
  inline void clear_has_vlti();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 sti_;
  ::google::protobuf::int32 lti_;
  ::google::protobuf::int32 vlti_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQAttentionValueHolderMessage* default_instance_;
};
// -------------------------------------------------------------------

class ZMQVersionHandleMessage : public ::google::protobuf::Message {
 public:
  ZMQVersionHandleMessage();
  virtual ~ZMQVersionHandleMessage();
  
  ZMQVersionHandleMessage(const ZMQVersionHandleMessage& from);
  
  inline ZMQVersionHandleMessage& operator=(const ZMQVersionHandleMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQVersionHandleMessage& default_instance();
  
  void Swap(ZMQVersionHandleMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQVersionHandleMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQVersionHandleMessage& from);
  void MergeFrom(const ZMQVersionHandleMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 indicator = 1;
  inline bool has_indicator() const;
  inline void clear_indicator();
  static const int kIndicatorFieldNumber = 1;
  inline ::google::protobuf::uint32 indicator() const;
  inline void set_indicator(::google::protobuf::uint32 value);
  
  // required uint64 substantive = 2;
  inline bool has_substantive() const;
  inline void clear_substantive();
  static const int kSubstantiveFieldNumber = 2;
  inline ::google::protobuf::uint64 substantive() const;
  inline void set_substantive(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ZMQVersionHandleMessage)
 private:
  inline void set_has_indicator();
  inline void clear_has_indicator();
  inline void set_has_substantive();
  inline void clear_has_substantive();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 substantive_;
  ::google::protobuf::uint32 indicator_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQVersionHandleMessage* default_instance_;
};
// -------------------------------------------------------------------

class ZMQSingleTruthValueMessage : public ::google::protobuf::Message {
 public:
  ZMQSingleTruthValueMessage();
  virtual ~ZMQSingleTruthValueMessage();
  
  ZMQSingleTruthValueMessage(const ZMQSingleTruthValueMessage& from);
  
  inline ZMQSingleTruthValueMessage& operator=(const ZMQSingleTruthValueMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQSingleTruthValueMessage& default_instance();
  
  void Swap(ZMQSingleTruthValueMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQSingleTruthValueMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQSingleTruthValueMessage& from);
  void MergeFrom(const ZMQSingleTruthValueMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ZMQTruthValueType truthvaluetype = 1;
  inline bool has_truthvaluetype() const;
  inline void clear_truthvaluetype();
  static const int kTruthvaluetypeFieldNumber = 1;
  inline ZMQTruthValueType truthvaluetype() const;
  inline void set_truthvaluetype(ZMQTruthValueType value);
  
  // optional float mean = 2;
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 2;
  inline float mean() const;
  inline void set_mean(float value);
  
  // optional float confidence = 3;
  inline bool has_confidence() const;
  inline void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  inline float confidence() const;
  inline void set_confidence(float value);
  
  // optional float count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline float count() const;
  inline void set_count(float value);
  
  // optional .ZMQVersionHandleMessage versionHandle = 5;
  inline bool has_versionhandle() const;
  inline void clear_versionhandle();
  static const int kVersionHandleFieldNumber = 5;
  inline const ::ZMQVersionHandleMessage& versionhandle() const;
  inline ::ZMQVersionHandleMessage* mutable_versionhandle();
  inline ::ZMQVersionHandleMessage* release_versionhandle();
  
  // optional float U = 6;
  inline bool has_u() const;
  inline void clear_u();
  static const int kUFieldNumber = 6;
  inline float u() const;
  inline void set_u(float value);
  
  // optional float L = 7;
  inline bool has_l() const;
  inline void clear_l();
  static const int kLFieldNumber = 7;
  inline float l() const;
  inline void set_l(float value);
  
  // optional float confidenceLevel = 8;
  inline bool has_confidencelevel() const;
  inline void clear_confidencelevel();
  static const int kConfidenceLevelFieldNumber = 8;
  inline float confidencelevel() const;
  inline void set_confidencelevel(float value);
  
  // optional int32 symmetric = 9;
  inline bool has_symmetric() const;
  inline void clear_symmetric();
  static const int kSymmetricFieldNumber = 9;
  inline ::google::protobuf::int32 symmetric() const;
  inline void set_symmetric(::google::protobuf::int32 value);
  
  // optional float diff = 10;
  inline bool has_diff() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 10;
  inline float diff() const;
  inline void set_diff(float value);
  
  // repeated float firstOrderDistribution = 11;
  inline int firstorderdistribution_size() const;
  inline void clear_firstorderdistribution();
  static const int kFirstOrderDistributionFieldNumber = 11;
  inline float firstorderdistribution(int index) const;
  inline void set_firstorderdistribution(int index, float value);
  inline void add_firstorderdistribution(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      firstorderdistribution() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_firstorderdistribution();
  
  // @@protoc_insertion_point(class_scope:ZMQSingleTruthValueMessage)
 private:
  inline void set_has_truthvaluetype();
  inline void clear_has_truthvaluetype();
  inline void set_has_mean();
  inline void clear_has_mean();
  inline void set_has_confidence();
  inline void clear_has_confidence();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_versionhandle();
  inline void clear_has_versionhandle();
  inline void set_has_u();
  inline void clear_has_u();
  inline void set_has_l();
  inline void clear_has_l();
  inline void set_has_confidencelevel();
  inline void clear_has_confidencelevel();
  inline void set_has_symmetric();
  inline void clear_has_symmetric();
  inline void set_has_diff();
  inline void clear_has_diff();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int truthvaluetype_;
  float mean_;
  float confidence_;
  float count_;
  ::ZMQVersionHandleMessage* versionhandle_;
  float u_;
  float l_;
  float confidencelevel_;
  ::google::protobuf::int32 symmetric_;
  ::google::protobuf::RepeatedField< float > firstorderdistribution_;
  float diff_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQSingleTruthValueMessage* default_instance_;
};
// -------------------------------------------------------------------

class ZMQTruthValueMessage : public ::google::protobuf::Message {
 public:
  ZMQTruthValueMessage();
  virtual ~ZMQTruthValueMessage();
  
  ZMQTruthValueMessage(const ZMQTruthValueMessage& from);
  
  inline ZMQTruthValueMessage& operator=(const ZMQTruthValueMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQTruthValueMessage& default_instance();
  
  void Swap(ZMQTruthValueMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQTruthValueMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQTruthValueMessage& from);
  void MergeFrom(const ZMQTruthValueMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ZMQSingleTruthValueMessage singleTruthValue = 1;
  inline int singletruthvalue_size() const;
  inline void clear_singletruthvalue();
  static const int kSingleTruthValueFieldNumber = 1;
  inline const ::ZMQSingleTruthValueMessage& singletruthvalue(int index) const;
  inline ::ZMQSingleTruthValueMessage* mutable_singletruthvalue(int index);
  inline ::ZMQSingleTruthValueMessage* add_singletruthvalue();
  inline const ::google::protobuf::RepeatedPtrField< ::ZMQSingleTruthValueMessage >&
      singletruthvalue() const;
  inline ::google::protobuf::RepeatedPtrField< ::ZMQSingleTruthValueMessage >*
      mutable_singletruthvalue();
  
  // @@protoc_insertion_point(class_scope:ZMQTruthValueMessage)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ZMQSingleTruthValueMessage > singletruthvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQTruthValueMessage* default_instance_;
};
// -------------------------------------------------------------------

class ZMQTrailMessage : public ::google::protobuf::Message {
 public:
  ZMQTrailMessage();
  virtual ~ZMQTrailMessage();
  
  ZMQTrailMessage(const ZMQTrailMessage& from);
  
  inline ZMQTrailMessage& operator=(const ZMQTrailMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQTrailMessage& default_instance();
  
  void Swap(ZMQTrailMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQTrailMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQTrailMessage& from);
  void MergeFrom(const ZMQTrailMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 maxSize = 1;
  inline bool has_maxsize() const;
  inline void clear_maxsize();
  static const int kMaxSizeFieldNumber = 1;
  inline ::google::protobuf::int32 maxsize() const;
  inline void set_maxsize(::google::protobuf::int32 value);
  
  // repeated uint64 trail = 2;
  inline int trail_size() const;
  inline void clear_trail();
  static const int kTrailFieldNumber = 2;
  inline ::google::protobuf::uint64 trail(int index) const;
  inline void set_trail(int index, ::google::protobuf::uint64 value);
  inline void add_trail(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      trail() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_trail();
  
  // @@protoc_insertion_point(class_scope:ZMQTrailMessage)
 private:
  inline void set_has_maxsize();
  inline void clear_has_maxsize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > trail_;
  ::google::protobuf::int32 maxsize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQTrailMessage* default_instance_;
};
// -------------------------------------------------------------------

class ZMQAtomMessage : public ::google::protobuf::Message {
 public:
  ZMQAtomMessage();
  virtual ~ZMQAtomMessage();
  
  ZMQAtomMessage(const ZMQAtomMessage& from);
  
  inline ZMQAtomMessage& operator=(const ZMQAtomMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQAtomMessage& default_instance();
  
  void Swap(ZMQAtomMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQAtomMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQAtomMessage& from);
  void MergeFrom(const ZMQAtomMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ZMQAtomType atomtype = 1;
  inline bool has_atomtype() const;
  inline void clear_atomtype();
  static const int kAtomtypeFieldNumber = 1;
  inline ZMQAtomType atomtype() const;
  inline void set_atomtype(ZMQAtomType value);
  
  // required .ZMQAttentionValueHolderMessage attentionvalueholder = 2;
  inline bool has_attentionvalueholder() const;
  inline void clear_attentionvalueholder();
  static const int kAttentionvalueholderFieldNumber = 2;
  inline const ::ZMQAttentionValueHolderMessage& attentionvalueholder() const;
  inline ::ZMQAttentionValueHolderMessage* mutable_attentionvalueholder();
  inline ::ZMQAttentionValueHolderMessage* release_attentionvalueholder();
  
  // required uint64 handle = 3;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 3;
  inline ::google::protobuf::uint64 handle() const;
  inline void set_handle(::google::protobuf::uint64 value);
  
  // repeated uint64 incoming = 4;
  inline int incoming_size() const;
  inline void clear_incoming();
  static const int kIncomingFieldNumber = 4;
  inline ::google::protobuf::uint64 incoming(int index) const;
  inline void set_incoming(int index, ::google::protobuf::uint64 value);
  inline void add_incoming(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      incoming() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_incoming();
  
  // required int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional int32 flags = 6;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 6;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);
  
  // optional .ZMQTruthValueMessage truthValue = 7;
  inline bool has_truthvalue() const;
  inline void clear_truthvalue();
  static const int kTruthValueFieldNumber = 7;
  inline const ::ZMQTruthValueMessage& truthvalue() const;
  inline ::ZMQTruthValueMessage* mutable_truthvalue();
  inline ::ZMQTruthValueMessage* release_truthvalue();
  
  // optional string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated uint64 outgoing = 9;
  inline int outgoing_size() const;
  inline void clear_outgoing();
  static const int kOutgoingFieldNumber = 9;
  inline ::google::protobuf::uint64 outgoing(int index) const;
  inline void set_outgoing(int index, ::google::protobuf::uint64 value);
  inline void add_outgoing(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      outgoing() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_outgoing();
  
  // optional .ZMQTrailMessage trail = 10;
  inline bool has_trail() const;
  inline void clear_trail();
  static const int kTrailFieldNumber = 10;
  inline const ::ZMQTrailMessage& trail() const;
  inline ::ZMQTrailMessage* mutable_trail();
  inline ::ZMQTrailMessage* release_trail();
  
  // @@protoc_insertion_point(class_scope:ZMQAtomMessage)
 private:
  inline void set_has_atomtype();
  inline void clear_has_atomtype();
  inline void set_has_attentionvalueholder();
  inline void clear_has_attentionvalueholder();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_truthvalue();
  inline void clear_has_truthvalue();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_trail();
  inline void clear_has_trail();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ZMQAttentionValueHolderMessage* attentionvalueholder_;
  ::google::protobuf::uint64 handle_;
  int atomtype_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > incoming_;
  ::ZMQTruthValueMessage* truthvalue_;
  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > outgoing_;
  ::ZMQTrailMessage* trail_;
  ::google::protobuf::int32 flags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQAtomMessage* default_instance_;
};
// -------------------------------------------------------------------

class ZMQRequestMessage : public ::google::protobuf::Message {
 public:
  ZMQRequestMessage();
  virtual ~ZMQRequestMessage();
  
  ZMQRequestMessage(const ZMQRequestMessage& from);
  
  inline ZMQRequestMessage& operator=(const ZMQRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQRequestMessage& default_instance();
  
  void Swap(ZMQRequestMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQRequestMessage& from);
  void MergeFrom(const ZMQRequestMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ZMQFunctionType function = 1;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 1;
  inline ZMQFunctionType function() const;
  inline void set_function(ZMQFunctionType value);
  
  // optional uint64 handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline ::google::protobuf::uint64 handle() const;
  inline void set_handle(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ZMQRequestMessage)
 private:
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_handle();
  inline void clear_has_handle();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 handle_;
  int function_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class ZMQReplyMessage : public ::google::protobuf::Message {
 public:
  ZMQReplyMessage();
  virtual ~ZMQReplyMessage();
  
  ZMQReplyMessage(const ZMQReplyMessage& from);
  
  inline ZMQReplyMessage& operator=(const ZMQReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQReplyMessage& default_instance();
  
  void Swap(ZMQReplyMessage* other);
  
  // implements Message ----------------------------------------------
  
  ZMQReplyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQReplyMessage& from);
  void MergeFrom(const ZMQReplyMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ZMQAtomMessage atom = 1;
  inline bool has_atom() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 1;
  inline const ::ZMQAtomMessage& atom() const;
  inline ::ZMQAtomMessage* mutable_atom();
  inline ::ZMQAtomMessage* release_atom();
  
  // optional string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  
  // @@protoc_insertion_point(class_scope:ZMQReplyMessage)
 private:
  inline void set_has_atom();
  inline void clear_has_atom();
  inline void set_has_str();
  inline void clear_has_str();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ZMQAtomMessage* atom_;
  ::std::string* str_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ZMQMessages_2eproto();
  friend void protobuf_AssignDesc_ZMQMessages_2eproto();
  friend void protobuf_ShutdownFile_ZMQMessages_2eproto();
  
  void InitAsDefaultInstance();
  static ZMQReplyMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ZMQAttentionValueHolderMessage

// required int32 STI = 1;
inline bool ZMQAttentionValueHolderMessage::has_sti() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQAttentionValueHolderMessage::set_has_sti() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQAttentionValueHolderMessage::clear_has_sti() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQAttentionValueHolderMessage::clear_sti() {
  sti_ = 0;
  clear_has_sti();
}
inline ::google::protobuf::int32 ZMQAttentionValueHolderMessage::sti() const {
  return sti_;
}
inline void ZMQAttentionValueHolderMessage::set_sti(::google::protobuf::int32 value) {
  set_has_sti();
  sti_ = value;
}

// required int32 LTI = 2;
inline bool ZMQAttentionValueHolderMessage::has_lti() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQAttentionValueHolderMessage::set_has_lti() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQAttentionValueHolderMessage::clear_has_lti() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQAttentionValueHolderMessage::clear_lti() {
  lti_ = 0;
  clear_has_lti();
}
inline ::google::protobuf::int32 ZMQAttentionValueHolderMessage::lti() const {
  return lti_;
}
inline void ZMQAttentionValueHolderMessage::set_lti(::google::protobuf::int32 value) {
  set_has_lti();
  lti_ = value;
}

// required int32 VLTI = 3;
inline bool ZMQAttentionValueHolderMessage::has_vlti() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZMQAttentionValueHolderMessage::set_has_vlti() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZMQAttentionValueHolderMessage::clear_has_vlti() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZMQAttentionValueHolderMessage::clear_vlti() {
  vlti_ = 0;
  clear_has_vlti();
}
inline ::google::protobuf::int32 ZMQAttentionValueHolderMessage::vlti() const {
  return vlti_;
}
inline void ZMQAttentionValueHolderMessage::set_vlti(::google::protobuf::int32 value) {
  set_has_vlti();
  vlti_ = value;
}

// -------------------------------------------------------------------

// ZMQVersionHandleMessage

// required uint32 indicator = 1;
inline bool ZMQVersionHandleMessage::has_indicator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQVersionHandleMessage::set_has_indicator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQVersionHandleMessage::clear_has_indicator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQVersionHandleMessage::clear_indicator() {
  indicator_ = 0u;
  clear_has_indicator();
}
inline ::google::protobuf::uint32 ZMQVersionHandleMessage::indicator() const {
  return indicator_;
}
inline void ZMQVersionHandleMessage::set_indicator(::google::protobuf::uint32 value) {
  set_has_indicator();
  indicator_ = value;
}

// required uint64 substantive = 2;
inline bool ZMQVersionHandleMessage::has_substantive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQVersionHandleMessage::set_has_substantive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQVersionHandleMessage::clear_has_substantive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQVersionHandleMessage::clear_substantive() {
  substantive_ = GOOGLE_ULONGLONG(0);
  clear_has_substantive();
}
inline ::google::protobuf::uint64 ZMQVersionHandleMessage::substantive() const {
  return substantive_;
}
inline void ZMQVersionHandleMessage::set_substantive(::google::protobuf::uint64 value) {
  set_has_substantive();
  substantive_ = value;
}

// -------------------------------------------------------------------

// ZMQSingleTruthValueMessage

// required .ZMQTruthValueType truthvaluetype = 1;
inline bool ZMQSingleTruthValueMessage::has_truthvaluetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_truthvaluetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQSingleTruthValueMessage::clear_has_truthvaluetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQSingleTruthValueMessage::clear_truthvaluetype() {
  truthvaluetype_ = 0;
  clear_has_truthvaluetype();
}
inline ZMQTruthValueType ZMQSingleTruthValueMessage::truthvaluetype() const {
  return static_cast< ZMQTruthValueType >(truthvaluetype_);
}
inline void ZMQSingleTruthValueMessage::set_truthvaluetype(ZMQTruthValueType value) {
  GOOGLE_DCHECK(ZMQTruthValueType_IsValid(value));
  set_has_truthvaluetype();
  truthvaluetype_ = value;
}

// optional float mean = 2;
inline bool ZMQSingleTruthValueMessage::has_mean() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_mean() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQSingleTruthValueMessage::clear_has_mean() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQSingleTruthValueMessage::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline float ZMQSingleTruthValueMessage::mean() const {
  return mean_;
}
inline void ZMQSingleTruthValueMessage::set_mean(float value) {
  set_has_mean();
  mean_ = value;
}

// optional float confidence = 3;
inline bool ZMQSingleTruthValueMessage::has_confidence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_confidence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZMQSingleTruthValueMessage::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZMQSingleTruthValueMessage::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float ZMQSingleTruthValueMessage::confidence() const {
  return confidence_;
}
inline void ZMQSingleTruthValueMessage::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
}

// optional float count = 4;
inline bool ZMQSingleTruthValueMessage::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZMQSingleTruthValueMessage::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZMQSingleTruthValueMessage::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline float ZMQSingleTruthValueMessage::count() const {
  return count_;
}
inline void ZMQSingleTruthValueMessage::set_count(float value) {
  set_has_count();
  count_ = value;
}

// optional .ZMQVersionHandleMessage versionHandle = 5;
inline bool ZMQSingleTruthValueMessage::has_versionhandle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_versionhandle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ZMQSingleTruthValueMessage::clear_has_versionhandle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ZMQSingleTruthValueMessage::clear_versionhandle() {
  if (versionhandle_ != NULL) versionhandle_->::ZMQVersionHandleMessage::Clear();
  clear_has_versionhandle();
}
inline const ::ZMQVersionHandleMessage& ZMQSingleTruthValueMessage::versionhandle() const {
  return versionhandle_ != NULL ? *versionhandle_ : *default_instance_->versionhandle_;
}
inline ::ZMQVersionHandleMessage* ZMQSingleTruthValueMessage::mutable_versionhandle() {
  set_has_versionhandle();
  if (versionhandle_ == NULL) versionhandle_ = new ::ZMQVersionHandleMessage;
  return versionhandle_;
}
inline ::ZMQVersionHandleMessage* ZMQSingleTruthValueMessage::release_versionhandle() {
  clear_has_versionhandle();
  ::ZMQVersionHandleMessage* temp = versionhandle_;
  versionhandle_ = NULL;
  return temp;
}

// optional float U = 6;
inline bool ZMQSingleTruthValueMessage::has_u() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_u() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ZMQSingleTruthValueMessage::clear_has_u() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ZMQSingleTruthValueMessage::clear_u() {
  u_ = 0;
  clear_has_u();
}
inline float ZMQSingleTruthValueMessage::u() const {
  return u_;
}
inline void ZMQSingleTruthValueMessage::set_u(float value) {
  set_has_u();
  u_ = value;
}

// optional float L = 7;
inline bool ZMQSingleTruthValueMessage::has_l() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_l() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ZMQSingleTruthValueMessage::clear_has_l() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ZMQSingleTruthValueMessage::clear_l() {
  l_ = 0;
  clear_has_l();
}
inline float ZMQSingleTruthValueMessage::l() const {
  return l_;
}
inline void ZMQSingleTruthValueMessage::set_l(float value) {
  set_has_l();
  l_ = value;
}

// optional float confidenceLevel = 8;
inline bool ZMQSingleTruthValueMessage::has_confidencelevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_confidencelevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ZMQSingleTruthValueMessage::clear_has_confidencelevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ZMQSingleTruthValueMessage::clear_confidencelevel() {
  confidencelevel_ = 0;
  clear_has_confidencelevel();
}
inline float ZMQSingleTruthValueMessage::confidencelevel() const {
  return confidencelevel_;
}
inline void ZMQSingleTruthValueMessage::set_confidencelevel(float value) {
  set_has_confidencelevel();
  confidencelevel_ = value;
}

// optional int32 symmetric = 9;
inline bool ZMQSingleTruthValueMessage::has_symmetric() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_symmetric() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ZMQSingleTruthValueMessage::clear_has_symmetric() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ZMQSingleTruthValueMessage::clear_symmetric() {
  symmetric_ = 0;
  clear_has_symmetric();
}
inline ::google::protobuf::int32 ZMQSingleTruthValueMessage::symmetric() const {
  return symmetric_;
}
inline void ZMQSingleTruthValueMessage::set_symmetric(::google::protobuf::int32 value) {
  set_has_symmetric();
  symmetric_ = value;
}

// optional float diff = 10;
inline bool ZMQSingleTruthValueMessage::has_diff() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ZMQSingleTruthValueMessage::set_has_diff() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ZMQSingleTruthValueMessage::clear_has_diff() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ZMQSingleTruthValueMessage::clear_diff() {
  diff_ = 0;
  clear_has_diff();
}
inline float ZMQSingleTruthValueMessage::diff() const {
  return diff_;
}
inline void ZMQSingleTruthValueMessage::set_diff(float value) {
  set_has_diff();
  diff_ = value;
}

// repeated float firstOrderDistribution = 11;
inline int ZMQSingleTruthValueMessage::firstorderdistribution_size() const {
  return firstorderdistribution_.size();
}
inline void ZMQSingleTruthValueMessage::clear_firstorderdistribution() {
  firstorderdistribution_.Clear();
}
inline float ZMQSingleTruthValueMessage::firstorderdistribution(int index) const {
  return firstorderdistribution_.Get(index);
}
inline void ZMQSingleTruthValueMessage::set_firstorderdistribution(int index, float value) {
  firstorderdistribution_.Set(index, value);
}
inline void ZMQSingleTruthValueMessage::add_firstorderdistribution(float value) {
  firstorderdistribution_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ZMQSingleTruthValueMessage::firstorderdistribution() const {
  return firstorderdistribution_;
}
inline ::google::protobuf::RepeatedField< float >*
ZMQSingleTruthValueMessage::mutable_firstorderdistribution() {
  return &firstorderdistribution_;
}

// -------------------------------------------------------------------

// ZMQTruthValueMessage

// repeated .ZMQSingleTruthValueMessage singleTruthValue = 1;
inline int ZMQTruthValueMessage::singletruthvalue_size() const {
  return singletruthvalue_.size();
}
inline void ZMQTruthValueMessage::clear_singletruthvalue() {
  singletruthvalue_.Clear();
}
inline const ::ZMQSingleTruthValueMessage& ZMQTruthValueMessage::singletruthvalue(int index) const {
  return singletruthvalue_.Get(index);
}
inline ::ZMQSingleTruthValueMessage* ZMQTruthValueMessage::mutable_singletruthvalue(int index) {
  return singletruthvalue_.Mutable(index);
}
inline ::ZMQSingleTruthValueMessage* ZMQTruthValueMessage::add_singletruthvalue() {
  return singletruthvalue_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ZMQSingleTruthValueMessage >&
ZMQTruthValueMessage::singletruthvalue() const {
  return singletruthvalue_;
}
inline ::google::protobuf::RepeatedPtrField< ::ZMQSingleTruthValueMessage >*
ZMQTruthValueMessage::mutable_singletruthvalue() {
  return &singletruthvalue_;
}

// -------------------------------------------------------------------

// ZMQTrailMessage

// required int32 maxSize = 1;
inline bool ZMQTrailMessage::has_maxsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQTrailMessage::set_has_maxsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQTrailMessage::clear_has_maxsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQTrailMessage::clear_maxsize() {
  maxsize_ = 0;
  clear_has_maxsize();
}
inline ::google::protobuf::int32 ZMQTrailMessage::maxsize() const {
  return maxsize_;
}
inline void ZMQTrailMessage::set_maxsize(::google::protobuf::int32 value) {
  set_has_maxsize();
  maxsize_ = value;
}

// repeated uint64 trail = 2;
inline int ZMQTrailMessage::trail_size() const {
  return trail_.size();
}
inline void ZMQTrailMessage::clear_trail() {
  trail_.Clear();
}
inline ::google::protobuf::uint64 ZMQTrailMessage::trail(int index) const {
  return trail_.Get(index);
}
inline void ZMQTrailMessage::set_trail(int index, ::google::protobuf::uint64 value) {
  trail_.Set(index, value);
}
inline void ZMQTrailMessage::add_trail(::google::protobuf::uint64 value) {
  trail_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ZMQTrailMessage::trail() const {
  return trail_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ZMQTrailMessage::mutable_trail() {
  return &trail_;
}

// -------------------------------------------------------------------

// ZMQAtomMessage

// required .ZMQAtomType atomtype = 1;
inline bool ZMQAtomMessage::has_atomtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQAtomMessage::set_has_atomtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQAtomMessage::clear_has_atomtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQAtomMessage::clear_atomtype() {
  atomtype_ = 0;
  clear_has_atomtype();
}
inline ZMQAtomType ZMQAtomMessage::atomtype() const {
  return static_cast< ZMQAtomType >(atomtype_);
}
inline void ZMQAtomMessage::set_atomtype(ZMQAtomType value) {
  GOOGLE_DCHECK(ZMQAtomType_IsValid(value));
  set_has_atomtype();
  atomtype_ = value;
}

// required .ZMQAttentionValueHolderMessage attentionvalueholder = 2;
inline bool ZMQAtomMessage::has_attentionvalueholder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQAtomMessage::set_has_attentionvalueholder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQAtomMessage::clear_has_attentionvalueholder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQAtomMessage::clear_attentionvalueholder() {
  if (attentionvalueholder_ != NULL) attentionvalueholder_->::ZMQAttentionValueHolderMessage::Clear();
  clear_has_attentionvalueholder();
}
inline const ::ZMQAttentionValueHolderMessage& ZMQAtomMessage::attentionvalueholder() const {
  return attentionvalueholder_ != NULL ? *attentionvalueholder_ : *default_instance_->attentionvalueholder_;
}
inline ::ZMQAttentionValueHolderMessage* ZMQAtomMessage::mutable_attentionvalueholder() {
  set_has_attentionvalueholder();
  if (attentionvalueholder_ == NULL) attentionvalueholder_ = new ::ZMQAttentionValueHolderMessage;
  return attentionvalueholder_;
}
inline ::ZMQAttentionValueHolderMessage* ZMQAtomMessage::release_attentionvalueholder() {
  clear_has_attentionvalueholder();
  ::ZMQAttentionValueHolderMessage* temp = attentionvalueholder_;
  attentionvalueholder_ = NULL;
  return temp;
}

// required uint64 handle = 3;
inline bool ZMQAtomMessage::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZMQAtomMessage::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZMQAtomMessage::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZMQAtomMessage::clear_handle() {
  handle_ = GOOGLE_ULONGLONG(0);
  clear_has_handle();
}
inline ::google::protobuf::uint64 ZMQAtomMessage::handle() const {
  return handle_;
}
inline void ZMQAtomMessage::set_handle(::google::protobuf::uint64 value) {
  set_has_handle();
  handle_ = value;
}

// repeated uint64 incoming = 4;
inline int ZMQAtomMessage::incoming_size() const {
  return incoming_.size();
}
inline void ZMQAtomMessage::clear_incoming() {
  incoming_.Clear();
}
inline ::google::protobuf::uint64 ZMQAtomMessage::incoming(int index) const {
  return incoming_.Get(index);
}
inline void ZMQAtomMessage::set_incoming(int index, ::google::protobuf::uint64 value) {
  incoming_.Set(index, value);
}
inline void ZMQAtomMessage::add_incoming(::google::protobuf::uint64 value) {
  incoming_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ZMQAtomMessage::incoming() const {
  return incoming_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ZMQAtomMessage::mutable_incoming() {
  return &incoming_;
}

// required int32 type = 5;
inline bool ZMQAtomMessage::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ZMQAtomMessage::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ZMQAtomMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ZMQAtomMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ZMQAtomMessage::type() const {
  return type_;
}
inline void ZMQAtomMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 flags = 6;
inline bool ZMQAtomMessage::has_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ZMQAtomMessage::set_has_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ZMQAtomMessage::clear_has_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ZMQAtomMessage::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 ZMQAtomMessage::flags() const {
  return flags_;
}
inline void ZMQAtomMessage::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
}

// optional .ZMQTruthValueMessage truthValue = 7;
inline bool ZMQAtomMessage::has_truthvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ZMQAtomMessage::set_has_truthvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ZMQAtomMessage::clear_has_truthvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ZMQAtomMessage::clear_truthvalue() {
  if (truthvalue_ != NULL) truthvalue_->::ZMQTruthValueMessage::Clear();
  clear_has_truthvalue();
}
inline const ::ZMQTruthValueMessage& ZMQAtomMessage::truthvalue() const {
  return truthvalue_ != NULL ? *truthvalue_ : *default_instance_->truthvalue_;
}
inline ::ZMQTruthValueMessage* ZMQAtomMessage::mutable_truthvalue() {
  set_has_truthvalue();
  if (truthvalue_ == NULL) truthvalue_ = new ::ZMQTruthValueMessage;
  return truthvalue_;
}
inline ::ZMQTruthValueMessage* ZMQAtomMessage::release_truthvalue() {
  clear_has_truthvalue();
  ::ZMQTruthValueMessage* temp = truthvalue_;
  truthvalue_ = NULL;
  return temp;
}

// optional string name = 8;
inline bool ZMQAtomMessage::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ZMQAtomMessage::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ZMQAtomMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ZMQAtomMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ZMQAtomMessage::name() const {
  return *name_;
}
inline void ZMQAtomMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ZMQAtomMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ZMQAtomMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZMQAtomMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ZMQAtomMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated uint64 outgoing = 9;
inline int ZMQAtomMessage::outgoing_size() const {
  return outgoing_.size();
}
inline void ZMQAtomMessage::clear_outgoing() {
  outgoing_.Clear();
}
inline ::google::protobuf::uint64 ZMQAtomMessage::outgoing(int index) const {
  return outgoing_.Get(index);
}
inline void ZMQAtomMessage::set_outgoing(int index, ::google::protobuf::uint64 value) {
  outgoing_.Set(index, value);
}
inline void ZMQAtomMessage::add_outgoing(::google::protobuf::uint64 value) {
  outgoing_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ZMQAtomMessage::outgoing() const {
  return outgoing_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ZMQAtomMessage::mutable_outgoing() {
  return &outgoing_;
}

// optional .ZMQTrailMessage trail = 10;
inline bool ZMQAtomMessage::has_trail() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ZMQAtomMessage::set_has_trail() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ZMQAtomMessage::clear_has_trail() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ZMQAtomMessage::clear_trail() {
  if (trail_ != NULL) trail_->::ZMQTrailMessage::Clear();
  clear_has_trail();
}
inline const ::ZMQTrailMessage& ZMQAtomMessage::trail() const {
  return trail_ != NULL ? *trail_ : *default_instance_->trail_;
}
inline ::ZMQTrailMessage* ZMQAtomMessage::mutable_trail() {
  set_has_trail();
  if (trail_ == NULL) trail_ = new ::ZMQTrailMessage;
  return trail_;
}
inline ::ZMQTrailMessage* ZMQAtomMessage::release_trail() {
  clear_has_trail();
  ::ZMQTrailMessage* temp = trail_;
  trail_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ZMQRequestMessage

// required .ZMQFunctionType function = 1;
inline bool ZMQRequestMessage::has_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQRequestMessage::set_has_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQRequestMessage::clear_has_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQRequestMessage::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ZMQFunctionType ZMQRequestMessage::function() const {
  return static_cast< ZMQFunctionType >(function_);
}
inline void ZMQRequestMessage::set_function(ZMQFunctionType value) {
  GOOGLE_DCHECK(ZMQFunctionType_IsValid(value));
  set_has_function();
  function_ = value;
}

// optional uint64 handle = 2;
inline bool ZMQRequestMessage::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQRequestMessage::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQRequestMessage::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQRequestMessage::clear_handle() {
  handle_ = GOOGLE_ULONGLONG(0);
  clear_has_handle();
}
inline ::google::protobuf::uint64 ZMQRequestMessage::handle() const {
  return handle_;
}
inline void ZMQRequestMessage::set_handle(::google::protobuf::uint64 value) {
  set_has_handle();
  handle_ = value;
}

// -------------------------------------------------------------------

// ZMQReplyMessage

// optional .ZMQAtomMessage atom = 1;
inline bool ZMQReplyMessage::has_atom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQReplyMessage::set_has_atom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQReplyMessage::clear_has_atom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQReplyMessage::clear_atom() {
  if (atom_ != NULL) atom_->::ZMQAtomMessage::Clear();
  clear_has_atom();
}
inline const ::ZMQAtomMessage& ZMQReplyMessage::atom() const {
  return atom_ != NULL ? *atom_ : *default_instance_->atom_;
}
inline ::ZMQAtomMessage* ZMQReplyMessage::mutable_atom() {
  set_has_atom();
  if (atom_ == NULL) atom_ = new ::ZMQAtomMessage;
  return atom_;
}
inline ::ZMQAtomMessage* ZMQReplyMessage::release_atom() {
  clear_has_atom();
  ::ZMQAtomMessage* temp = atom_;
  atom_ = NULL;
  return temp;
}

// optional string str = 2;
inline bool ZMQReplyMessage::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQReplyMessage::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQReplyMessage::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQReplyMessage::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& ZMQReplyMessage::str() const {
  return *str_;
}
inline void ZMQReplyMessage::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void ZMQReplyMessage::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void ZMQReplyMessage::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZMQReplyMessage::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* ZMQReplyMessage::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ZMQTruthValueType>() {
  return ZMQTruthValueType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ZMQAtomType>() {
  return ZMQAtomType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ZMQFunctionType>() {
  return ZMQFunctionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ZMQMessages_2eproto__INCLUDED
